import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { RestService } from './rest.service';
import { AppEnvironment } from './app-environment';
import * as FileSaver from 'file-saver';

describe('RestService', () => {
  let service: RestService;
  let httpMock: HttpTestingController;
  let mockAppEnv: AppEnvironment;

  beforeEach(() => {
    mockAppEnv = {
      serviceBaseUrl: 'http://localhost:3000',
      sgwtConnect: {
        isAuthorized: jasmine.createSpy('isAuthorized').and.returnValue(true),
        getAuthorizationHeader: jasmine.createSpy('getAuthorizationHeader').and.returnValue('Bearer token')
      }
    };

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        { provide: AppEnvironment, useValue: mockAppEnv },
        RestService
      ]
    });

    service = TestBed.inject(RestService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify();
  });

  // Test case for readExport method
  it('should download file correctly when authorized in readExport', () => {
    const serviceName = 'testService';
    const id = JSON.stringify({ id: 123, fileName: 'testfile.pdf' });
    const mockBlob = new Blob(['Test file content'], { type: 'application/pdf' });

    spyOn(FileSaver, 'saveAs'); // Mock FileSaver.saveAs

    service.readExport(serviceName, id).subscribe();

    const req = httpMock.expectOne('http://localhost:3000/testService/read/');
    expect(req.request.method).toBe('POST');
    req.flush(mockBlob, { headers: { 'Content-Type': 'application/pdf' } });

    // Check that FileSaver.saveAs was called with the correct parameters
    expect(FileSaver.saveAs).toHaveBeenCalledWith(mockBlob, 'testfile.pdf');
  });

  // Test case for unauthorized access in readExport
  it('should log SG_CONNECT_FAILED error when unauthorized in readExport', () => {
    mockAppEnv.sgwtConnect.isAuthorized.and.returnValue(false); // Mock unauthorized

    spyOn(console, 'error'); // Spy on console.error

    const serviceName = 'testService';
    const id = JSON.stringify({ id: 123, fileName: 'testfile.pdf' });

    service.readExport(serviceName, id).subscribe({
      next: () => fail('Expected an error, not a success'),
      error: (err) => {
        expect(console.error).toHaveBeenCalledWith('SG_CONNECT_FAILED');
      }
    });

    httpMock.expectNone(); // No HTTP request should be made
  });

  // Test case for readFromUrl method
  it('should make GET request and handle the response in readFromUrl', () => {
    const url = 'testService/data';
    const mockResponse = { data: 'test data' };

    service.readFromUrl(url).subscribe(response => {
      expect(response).toEqual(mockResponse);
    });

    const req = httpMock.expectOne('http://localhost:3000/testService/data');
    expect(req.request.method).toBe('GET');
    req.flush(mockResponse);
  });

  // Test case for unauthorized access in readFromUrl
  it('should log SG_CONNECT_FAILED error when unauthorized in readFromUrl', () => {
    mockAppEnv.sgwtConnect.isAuthorized.and.returnValue(false); // Mock unauthorized

    spyOn(console, 'error'); // Spy on console.error

    const url = 'testService/data';

    service.readFromUrl(url).subscribe({
      next: () => fail('Expected an error, not a success'),
      error: (err) => {
        expect(console.error).toHaveBeenCalledWith('SG_CONNECT_FAILED');
      }
    });

    httpMock.expectNone(); // No HTTP request should be made
  });

  // Test case for error handling in readFromUrl method
  it('should handle errors correctly in readFromUrl', () => {
    const url = 'testService/data';
    const mockError = { status: 500, statusText: 'Server Error' };

    spyOn(console, 'error'); // Spy on console.error

    service.readFromUrl(url).subscribe({
      next: () => fail('Expected an error, not a success'),
      error: (err) => {
        expect(console.error).toHaveBeenCalledWith('Error:', jasmine.anything());
      }
    });

    const req = httpMock.expectOne('http://localhost:3000/testService/data');
    req.error(new ErrorEvent('Network error'), mockError);
  });
});
